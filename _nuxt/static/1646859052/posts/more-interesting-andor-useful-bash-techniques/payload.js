__NUXT_JSONP__("/posts/more-interesting-andor-useful-bash-techniques", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad){return {data:[{post:{slug:"more-interesting-andor-useful-bash-techniques",description:"Some more really cool BASH tricks",title:"More Interesting and\u002For Useful BASH Techniques!",imagesource:M,imagecredit:M,image:"2011.10.28T14:00:00_more-interesting-andor-useful-bash-techniques.jpg",createdAt:N,updatedAt:N,toc:[{depth:n,text:O},{depth:n,text:P},{depth:n,text:Q},{depth:n,text:R},{depth:n,text:S},{depth:n,text:T},{depth:n,text:U},{depth:n,text:V}],body:{type:"root",children:[{type:b,tag:h,props:{},children:[{type:a,value:"Hi folks!"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Here's some more BASH snippets I've happened across since my last post. Hope you find some of them of use!"}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:O}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"I'm sure that many of you will have heard of using "},{type:b,tag:B,props:{},children:[{type:a,value:"dmidecode"}]},{type:a,value:" to do this. I've always found it to leave out critical data myself, so set out to find a better way to do it. Lo and behold, I came across "},{type:b,tag:"a",props:{href:"http:\u002F\u002Fwww.dufault.info\u002Fblog\u002Fa-better-way-to-find-your-bios-version-in-linux\u002F"},children:[{type:a,value:"this site"}]},{type:a,value:", which detailed the following method of grabbing the BIOS's details directly from RAM. Here goes:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"dd"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"if"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:a,value:"\u002Fdev\u002Fmem "},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"bs"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"32768"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"skip"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"31"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"count"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:C}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:W}]},{type:a,value:" strings -n "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"10"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:W}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"grep"}]},{type:a,value:" -i bios\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This reads 32k of your RAM, from 32*32k (1048576 bytes) onwards, then strips out anything but human readable strings at least 10 characters long. It lastly searches for any line containing the case-insensitive string \"bios\". Personally, I found that this came out with far more useful information than dmidecode ever could, without serious amounts of messing about, when working with different manufacturers' boards."}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:P}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This is one of the many uses of strace, which I've found to be an invaluable debugging tool. Have you ever been SSH'd onto a machine, and needed to read the console output of a command which is running on the remote machine? This is a perfect way to read its output, particularly if you can't find the terminal it's attached to. The command simply intercepts any call the process makes, which would cause it to write to file descriptor 1 or 2 (stdout, stderr)."}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"strace"}]},{type:a,value:" -ff -e "},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"trace"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:a,value:"write -e "},{type:b,tag:c,props:{className:[d,x,p]},children:[{type:a,value:"write"}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:y}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"1,2"}]},{type:a,value:" -p SOME_PID\n"}]}]}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:Q}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"One of BASH's lesser known loops is the "},{type:b,tag:B,props:{},children:[{type:a,value:X}]},{type:a,value:" loop. Its behaviour can be emulated in a number of ways with better known functions, but 'until' is an incredibly readable, and succinct way to achieve the repetition of a process until a certain point. Here's an technical example using ping's return code to hold up a script:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:X}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"ping"}]},{type:a,value:" -c1 www.google.com"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,D,E]},children:[{type:a,value:K}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,F]},children:[{type:a,value:"\"Unable to reach www.google.com\""}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"sleep"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"20"}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:_}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,D,E]},children:[{type:a,value:K}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,F]},children:[{type:a,value:"\"Successfully pinged Google!\""}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:R}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"I didn't know about this option until very recently, and had a number of massively inefficient scripts because of it. It's a simple command line parameter, which allows you to edit a file with sed, rather than just output it to a new file. Check it out:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:$}]},{type:a,value:" -i "},{type:b,tag:c,props:{className:[d,F]},children:[{type:a,value:"''"}]},{type:a,value:" -e "},{type:b,tag:c,props:{className:[d,F]},children:[{type:a,value:"'s\u002Ffoo\u002Fbar\u002Fg'"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:"{"}]},{type:a,value:"FILENAME"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:"}"}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Wasn't that so simple? The documentation for this process is slightly misleading, however. The man page states \"-i - edit files in place (makes backup if extension supplied)\". This does not mention that you must include a zero-length extension, if you do not want a backup, hence -i being followed by two single quotes."}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:S}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"By default, BASH is configured to be in Emacs mode. This means that you can use Emacs-like Ctrl+Letter commands to speed up your workflow. Here's a list of the various commands you can use:"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+a   Move cursor to beginning of line"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+e   Move cursor to end of line"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+w   Cut the last word"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+u   Cut everything before the cursor"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+k   Cut everything after the cursor"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+y   Paste"},{type:b,tag:w,props:{},children:[]},{type:a,value:"\nCtrl+_   Undo"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"I find the most useful of any of these to be \"Ctrl+u\", as this can be used to great effect when you've mistyped a password, as an instant return to the beginning of the line, without having to worry about how many characters you've backspaced."}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:T}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This is an interesting commands, using redirection and subshells to achieve a useful end:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:b,tag:c,props:{className:[d,D,E]},children:[{type:a,value:"command"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:A},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:A},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:G}]},{type:a,value:"tee stdout.log"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:H}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:I}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:A},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:A},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:G}]},{type:a,value:"tee stderr.log "},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:A},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:z}]},{type:a,value:"amp"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:I}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:H}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:U}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This CLI idea has been submitted by reader James."}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This method uses the "},{type:b,tag:B,props:{},children:[{type:a,value:"scrot"}]},{type:a,value:" command, which is available on *buntu systems via apt, but may not be on your chosen distribution. The scrot command is a lot more powerful than the previous method, as it has far more relevant parameters. Here's an excerpt from its man page:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:a,value:"-b, --border\n    When selecting a window, grab wm border too\n\n-c, --count\n    Display a countdown when used with delay.\n\n-d, --delay NUM\n    Wait NUM seconds before taking a shot.\n\n-e, --exec APP\n    Exec APP on the saved image.\n\n-q, --quality NUM\n    Image quality "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:C}]},{type:a,value:"-100"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:H}]},{type:a,value:" high value means high size, low compression.\n    Default: "},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:"75"}]},{type:a,value:". "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:G}]},{type:a,value:"Effect differs depending on "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"file"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"format"}]},{type:a,value:" chosen"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:H}]},{type:a,value:".\n\n-m, --multidisp\n    For multiple heads, grab shot from each and "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"join"}]},{type:a,value:" them together.\n\n-s, --select\n    Interactively "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"select"}]},{type:a,value:" a window or rectangle with the mouse.\n\n-u, --focused\n    Use the currently focused window.\n\n-t, --thumb NUM\n    generate thumbnail too. NUM is the percentage of the original size\n    "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aa}]},{type:a,value:" the thumbnail to be.\n\n-z, --silent\n    prevent beeping.\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Its usage is fairly simple, in the format scrot [options] [file]. If the file parameter is left out, the format will be chosen as PNG, and the name will be the current Unix timestamp."}]},{type:a,value:e},{type:b,tag:o,props:{},children:[{type:a,value:V}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"This CLI idea has also been submitted by reader James."}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"There's a simple way to exchange text within a variable, without piping it to "},{type:b,tag:B,props:{},children:[{type:a,value:$}]},{type:a,value:" or other process. It works as follows:"}]},{type:a,value:e},{type:b,tag:q,props:{className:[r]},children:[{type:b,tag:s,props:{className:[t,u]},children:[{type:b,tag:v,props:{},children:[{type:a,value:"$ "},{type:b,tag:c,props:{className:[d,k]},children:[{type:a,value:"ls"}]},{type:a,value:" -1 *.jpg\n"},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:C}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:I}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ab}]},{type:a,value:L},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:".jpg\n$ "},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:aa}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,"for-or-select",p]},children:[{type:a,value:"FILE"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:"in"}]},{type:a,value:" *.jpg"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:Y}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,D,E]},children:[{type:a,value:K}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"${FILE"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ad}]},{type:a,value:"jpg"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ad}]},{type:a,value:"gif}"}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:m}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,l]},children:[{type:a,value:_}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:C}]},{type:a,value:J},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:I}]},{type:a,value:J},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ab}]},{type:a,value:J},{type:b,tag:c,props:{className:[d,i]},children:[{type:a,value:ac}]},{type:a,value:J}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"As always, if anybody's got anything of interest to add, or any questions, just direct them to the comments!"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"n00b"}]}]},dir:"\u002Fposts",path:"\u002Fposts\u002Fmore-interesting-andor-useful-bash-techniques",extension:".md",readingStats:{text:"5 min read",minutes:4.56,time:273600,words:912}}}],fetch:{},mutations:void 0}}("text","element","span","token","\n"," ","punctuation","p","number","operator","function","keyword",";",2,"h2","variable","div","nuxt-content-highlight","pre","language-bash","line-numbers","code","br","assign-left","=","&","gt","em","1","builtin","class-name","string","(",")","2",".gif\n","echo",".jpg\n",null,"2011-10-28T14:00:00.000Z","Find BIOS version via CLI","Intercept the stdout\u002Fstderr of a process","Until loops","Edit a file in place with sed","BASH Emacs mode to speed up workflow","Output stdout and stderr to 2 different files","Another way to take screenshots from cli","Variable text substitution","|","until","do","\n        ","done","sed","for","3","4","\u002F")));